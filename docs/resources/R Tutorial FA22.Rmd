---
title: "R Tutorial FA22"
author: "Catherine Arnett"
date: "2022-10-14"
output: html_document
---

```{r, include = FALSE}
library(readr)

xie_2020 <- read_csv("G:/My Drive/Year 4/Fall 2022/Cat's RAs FA22/R Tutorial/xie_2020.csv")
frequency <- read_table("G:/My Drive/Year 4/Fall 2022/Cat's RAs FA22/R Tutorial/frequency.tsv", 
    col_names = FALSE)
colnames(frequency) <- c('rank', 'freq', 'item')
```


# Introduction

R is a popular coding language that is mostly used for data analysis. The principles of coding from other languages, such as Python, apply. So, once you know some R, it will be helpful in learning other coding languages. 

*   [Link to installing R/RStudio](https://rstudio-education.github.io/hopr/starting.html)
*   [Short tutorial, getting started on RStudio](https://www.youtube.com/watch?v=FIrsOBy5k58)

## What is a script doing?

Key vocabulary:

*   **Environment**: the virtual environment you are working in, where objects are stored
*   **Preamble**: where you call packages to your 
*   **(Working) Directory**: where the files that you are working on are saved
*   **Package**: a set of functions that have been pre-written and can be called once you have downloaded the package

R, like other coding languages, uses a script to accomplish a set of tasks. This script usually begins with **preamble**, where you call the **packages** you want to use. At the beginning of your script, you may also set your **working directory**, so you can open and save files. 

For example, this is what a very simple preamble might look like. Notice how it shows the version of R and the relevant packages. Versions are very important and must be compatible. Versions can be a big headache if you don't keep things updated.

```{r}
library(tidyverse)
```

An R script can do a variety of things, like open, modify, and create files; it can plot figures; it can create and evaluate models. 

## Console vs. Script

An important thing to keep in mind while using RStudio is to remember the difference between the console and the script. The **console**, which is usually in the bottom right of the window, is where all code is executed. Anything written here will go away as soon as you restart R or close RStudio. The **script** is where you write and save code that you can run again. There are some necessary hygiene tips to make sure your code is able to run again, which involve calling all packages and setting the working directory in the preamble; making sure anything relevant in the environment is created with the script; and including all the necessary functions in the correct order in the script. 

The console is a great way to test code or view objects that you have created, but anything that you want saved must be in the script.

## Objects, base R

Let's look at how to create and manipulate **objects**. Objects can be variables, numbers, datasets, etc. You assign a value (right) to an object (left) with a `<-` or `=`.

Some tips:

*   Objects must be continuous strings (no spaces), cannot start with a number
*   Once you've created an object you can print it with the `print()` function
*   `#` will turn the rest of the line into a **comment**, which do not run


```{r}

my_first_object <- 24
print(my_first_object)

```

Now, let's look at an object that is a list. 

```{r}

my_list <- c(1, 2, 3, 4)
print(my_list)

```

We can do a few things to this list, like reference the nth item in the list, according to its **index**. 

```{r}
# print the second item in the list
my_list[2]

#NB: unlike Python, indices start at 1
```
We can delete an element. Adding `[-3]` removes the third element of the list, but notice we have to save it back to the object, otherwise it won't save the change we've made

```{r}
print(my_list[-3]) #remove 3rd element, without saving
print(my_list) #see, not saved

my_list <- my_list[-3] #remove 3rd element, with saving
print(my_list) #see, saved
```

We can append an element as well. Let's say we want to add another number at the end of the list

```{r}
my_list[4] <- 10
print(my_list)
```
Now, let's look at **dataframes**. Think of these as spreadsheets, basically. These have rows and columns. This format allows us to manipulate large amounts of data according to the rows, columns, values, etc. `mtcars` is a pre-loaded dataframe that comes with R.

```{r, include = FALSE}
data(mtcars)
```

```{r}
#View lets you open the dataframe in a new window
View(mtcars)
```

`glimpse` is a function from the `tidyverse` package that let's us look at the different columns, e.g. `mpg`, `cyl`; what kind of element is in those columns, e.g. `dbl`; and some examples of the values. It also gives you the **shape** of the dataframe, which includes the number of rows and columns. In this case, there are 32 rows (each row represents a data point) and 11 volumns (11 features that we know about each datapoint).

```{r}
glimpse(mtcars)
```


## Shortcuts

*   Highlight code, `Ctrl + Enter` to run


# dplyr and tidyverse

One of the most useful packages is `tidyverse`, which contains another package `dyplr`. These packages help us to manipulate dataframes and learn useful statistics about them. 

One of the things that is unique to the `tidyverse` is the pipe operator `%>%`. This basically strings together lines of code and runs them all at one time, so you don't have to save all the intermediate steps as objects.

## Delete columns

You can delete columns by using the `select` function. Inside of the function you write `-c()`, which tells you to take the column you've selected and remove it. Inside, the inner parentheses, you write the name of the column you want to delete. 

```{r}
mtcars %>% #load the dataset
  select(-c(vs))
```

## Delete rows

There are at least two ways you can delete rows. The first is you can delete a row by its index. You call the dataframe and follow it with square brackets `[]` which tells R you are looking at a particular index or row. Inside, you use the same `-c()` operator to delete. Inside the parentheses, you write the row number you want to delete. Then you follow it with a comma. 

```{r}
mtcars[-c(2),]
```
The other way is to delete a row by the value in a particular column. We do that with the `dplyr` function `filter()`. We use the pipe operator to call the dataset, and we tell it to filter the dataset for all rows where the number of cylinders is exactly 6. The relevant operators are:

*   `==`: equals (requires double =)
*   `<`, `>`: less than, greater than
*   `<=`, `>=`: less than or equal to, greater than or equal to
*   `!=`: not equal to

```{r}
mtcars %>%
  filter(cyl == 6)
```

## Group and Summarise

We can start to get interesting statistics by grouping column values together and getting statistics. In this case, I used `group_by()` to group by values in the `$cyl` column. Then I used `summarise` to count the number of rows with each different `$cyl` value. This tells us that in the dataset, there are 11 4-cylinder cars, 7 6-cylinder cars, and 14 8-cylinder cars. 

```{r}
mtcars %>% 
  group_by(cyl) %>%
  summarise(n = n())
```
We can take other summary statistics, like mean. For example, I am saying what are the average miles-per-gallon according to the different number of syllables. Inside of the `summarise()` function, I create a new object `mean_mpg`, which is the mean over the `$mpg` column. To do this I use the `mean()` function. 

```{r}
mtcars %>% 
  group_by(cyl) %>%
  summarise(mean_mpg = mean(mpg))
```

Another useful function is `mutate()`

# Play with Dataset

Let's look at our dataset `xie_2020`. The first thing you'll notice are a lot of `NA` values. Remember the structure of the dataset. Depending on whether the word is one or two syllables, it will only have values for some of the columns. 

```{r}
glimpse(xie_2020)
```
Let's split this dataset in two: monosyllabic words and disyllabic words. 

```{r}
monosyllables <- xie_2020 %>%
  drop_na(`AA`) %>%
  select(-c(`A/AB`, ABAB, AABB))
```

```{r}
disyllables <- xie_2020 %>%
  drop_na(ABAB, AABB) %>%
  select(-c(`A/AB`,AA))
```

```{r}
glimpse(monosyllables)
glimpse(disyllables)
```

## Find useful statistics

One of the questions we might ask is "How many of the monosyllabic words in this database can be reduplicated?"

```{r}

monosyllables %>%
  group_by(AA) %>%
  summarise(n = n())

```

What if we want a proportion?

```{r}
length = nrow(monosyllables) 

monosyllables %>%
  group_by(AA) %>%
  summarise(n = n()) %>%
  mutate(prop = n/length) %>%
  select(-c(n))

```

## Add another variable

Now we can look at the same datasets, but their frequency data have been added: `mono_freq` and `disyll_freq`. 

```{r, include = FALSE}
mono_freq <- merge(monosyllables, frequency, by.x = 'Simplified', by.y = 'item')
disyll_freq <- merge(disyllables, frequency, by.x = 'Simplified', by.y = 'item')
```

```{r}
glimpse(mono_freq)
```
What is the mean frequency of a reduplicable monosyllabic word, compared to non-reduplicable?

```{r}
mono_freq %>%
  group_by(AA) %>%
  summarise(mean(freq))
```


## Plot